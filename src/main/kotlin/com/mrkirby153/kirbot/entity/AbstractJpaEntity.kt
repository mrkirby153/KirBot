package com.mrkirby153.kirbot.entity

import org.springframework.data.util.ProxyUtils
import java.io.Serializable
import java.lang.reflect.Field
import javax.persistence.GeneratedValue
import javax.persistence.GenerationType
import javax.persistence.Id
import javax.persistence.MappedSuperclass

/**
 * Abstract class for JPA entities in which the ID is a generated value. The auto generated id is
 * retrieved from the
 */
@MappedSuperclass
abstract class AbstractAutogeneratedJpaEntity<T : Serializable> : BaseAbstractJpaEntity<T>() {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    var id: T? = null

    override fun equals(other: Any?): Boolean {
        other ?: return false
        if (this === other) return true

        if (javaClass != ProxyUtils.getUserClass(other)) return false
        other as AbstractAutogeneratedJpaEntity<*>
        return if (null == this.id) false else this.id == other.id
    }

    override fun hashCode(): Int {
        return 42
    }
}

/**
 * Abstract class for JPA entities. Contains an [id] field as well as overridden [equals] and [hashCode]
 * methods
 *
 * For Hibernate compliance, the hash code for objects implementing this class is constant
 */
@MappedSuperclass
abstract class AbstractJpaEntity<T : Serializable>(@Id var id: T? = null) : BaseAbstractJpaEntity<T>() {

    override fun equals(other: Any?): Boolean {
        other ?: return false
        if (this === other) return true

        if (javaClass != ProxyUtils.getUserClass(other)) return false
        other as AbstractJpaEntity<*>
        return if (null == this.id) false else this.id == other.id
    }

    override fun hashCode(): Int {
        return 42
    }
}

/**
 * The base abstract class from which jpa entities extend from
 */
abstract class BaseAbstractJpaEntity<T : Serializable> {

    override fun toString(): String {
        val targetInstance = this

        val fields = fieldCache.computeIfAbsent(javaClass) {
            val fields = mutableListOf<Field>()
            var clazz: Class<*>? = javaClass
            while(clazz != null) {
                fields.addAll(clazz.declaredFields)
                clazz = clazz.superclass
            }
            fields
        }

        return buildString {
            append("${targetInstance.javaClass.canonicalName}{")
            append(fields.joinToString(", ") {
                try {
                    it.trySetAccessible()
                    "${it.name}=${it.get(targetInstance)}"
                } catch (ignored: SecurityException) {
                    ""
                }
            })
            append("}")
        }
    }

    companion object {
        private val fieldCache = mutableMapOf<Class<*>, List<Field>>()
    }
}