package com.mrkirby153.kirbot.entity

import org.springframework.data.annotation.CreatedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.sql.Timestamp
import javax.persistence.AttributeConverter
import javax.persistence.Column
import javax.persistence.Convert
import javax.persistence.Entity
import javax.persistence.EntityListeners
import javax.persistence.FetchType
import javax.persistence.JoinColumn
import javax.persistence.ManyToOne
import javax.persistence.Table

@Entity
@Table(name = "infractions")
@EntityListeners(AuditingEntityListener::class)
class Infraction(
        @Column(name = "user_id") var userId: String,
        @Column(name = "guild") var guild: String,
        @Column(name = "type") @Convert(
                converter = InfractionTypeConverter::class) var type: InfractionType,
        @Column(name = "reason") var reason: String,
        @Column(name = "active") var active: Boolean = true,
        @Column(name = "metadata") var metadata: String? = null,
        @Column(name = "created_at") @CreatedDate var createdAt: Timestamp? = null,
        @Column(name = "expires_at") var expiresAt: Timestamp? = null) :
        AbstractAutogeneratedJpaEntity<Long>() {

    @ManyToOne(cascade = [], fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", nullable = true, insertable = false, updatable = false)
    lateinit var user: DiscordUser

    enum class InfractionType(val dbName: String) {
        MUTE("mute"),
        TEMP_MUTE("tempmute"),
        KICK("kick"),
        BAN("ban"),
        UNBAN("unban"),
        TEMP_BAN("tempban"),
        WARN("warn")
    }

}

/**
 * Type converter to map [Infraction.InfractionType] to the existing values in the database
 */
class InfractionTypeConverter : AttributeConverter<Infraction.InfractionType, String> {
    override fun convertToDatabaseColumn(attribute: Infraction.InfractionType?): String? {
        return attribute?.dbName
    }

    override fun convertToEntityAttribute(dbData: String?): Infraction.InfractionType {
        val type = Infraction.InfractionType.values().filter { it.dbName == dbData }
        if (type.size > 1)
            throw IllegalArgumentException("Infraction attribute matched more than 1 type")
        if (type.isEmpty())
            throw IllegalArgumentException("Infraction attribute did not match any types ")
        return type.first()
    }
}